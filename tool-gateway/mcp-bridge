#!/usr/bin/env node
// Set module search path to include global modules
if (!process.env.NODE_PATH) {
  const { execSync } = require("child_process");
  try {
    const globalRoot = execSync("npm root -g", { encoding: "utf-8" }).trim();
    process.env.NODE_PATH = globalRoot;
    require("module").Module._initPaths();
  } catch {}
}
// ─────────────────────────────────────────────────────────────
// mcp-bridge — bridges MCP stdio to Streamable HTTP transport
//
// Uses the MCP SDK:
//   - McpServer (stdio) to talk to cagent
//   - Client + StreamableHTTPClientTransport to talk to tool-gateway
// ─────────────────────────────────────────────────────────────

const GATEWAY_URL = process.argv[2] || "http://tool-gateway:8081";

async function main() {
  const { Client } = require("@modelcontextprotocol/sdk/client/index.js");
  const {
    StreamableHTTPClientTransport,
  } = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
  const {
    StdioServerTransport,
  } = require("@modelcontextprotocol/sdk/server/stdio.js");
  const { McpServer } = require("@modelcontextprotocol/sdk/server/mcp.js");

  // Wait for gateway
  const adminUrl = GATEWAY_URL.replace(":8081", ":3100");
  for (let i = 0; i < 60; i++) {
    try {
      const r = await fetch(`${adminUrl}/health`);
      if (r.ok) break;
    } catch {}
    await new Promise((r) => setTimeout(r, 1000));
  }

  // Connect to tool-gateway as MCP client (with retry)
  process.stderr.write(`[mcp-bridge] Connecting to ${GATEWAY_URL}/mcp...\n`);
  let client;
  for (let attempt = 1; attempt <= 3; attempt++) {
    const clientTransport = new StreamableHTTPClientTransport(
      new URL(`${GATEWAY_URL}/mcp`)
    );
    client = new Client({ name: "mcp-bridge", version: "1.0.0" });
    try {
      await client.connect(clientTransport);
      break;
    } catch (err) {
      process.stderr.write(`[mcp-bridge] Connection attempt ${attempt}/3 failed: ${err.message}\n`);
      if (attempt === 3) throw err;
      await new Promise((r) => setTimeout(r, 2000));
    }
  }

  // Get available tools from the gateway
  const { tools: remoteTools } = await client.listTools();
  process.stderr.write(
    `[mcp-bridge] Connected, ${remoteTools.length} tools: ${remoteTools.map((t) => t.name).join(", ")}\n`
  );

  // Create a local MCP server (McpServer) that re-exposes those tools via stdio
  const server = new McpServer({ name: "mcp-bridge", version: "1.0.0" });

  // Re-register each remote tool locally so cagent discovers them
  const { z } = require("zod");

  // Convert JSON Schema → Zod type (recursive for nested schemas)
  function jsonSchemaToZod(prop, isRequired = true) {
    let zType;

    if (prop.type === "array" && prop.items) {
      // Array of items
      const itemType = jsonSchemaToZod(prop.items, true);
      zType = z.array(itemType);
    } else if (prop.type === "object" && prop.properties) {
      // Nested object
      const shape = {};
      for (const [k, v] of Object.entries(prop.properties)) {
        const req = prop.required && prop.required.includes(k);
        shape[k] = jsonSchemaToZod(v, req);
      }
      zType = z.object(shape);
    } else if (prop.enum) {
      // Enum values
      zType = z.enum(prop.enum);
    } else {
      switch (prop.type) {
        case "number":
        case "integer":
          zType = z.number();
          break;
        case "boolean":
          zType = z.boolean();
          break;
        default:
          zType = z.string();
      }
    }

    if (prop.description) zType = zType.describe(prop.description);
    if (!isRequired) zType = zType.optional();
    return zType;
  }

  for (const tool of remoteTools) {
    // Convert JSON Schema properties → Zod shape for McpServer.tool()
    const shape = {};
    if (tool.inputSchema?.properties) {
      for (const [key, prop] of Object.entries(tool.inputSchema.properties)) {
        const required =
          tool.inputSchema.required && tool.inputSchema.required.includes(key);
        shape[key] = jsonSchemaToZod(prop, required);
      }
    }

    server.tool(tool.name, tool.description || "", shape, async (args) => {
      process.stderr.write(`[mcp-bridge] → ${tool.name}\n`);
      try {
        // 2-minute timeout for tool calls (browser automation can be slow)
        const result = await Promise.race([
          client.callTool({ name: tool.name, arguments: args }),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error("Tool call timed out after 120s")), 120_000)
          ),
        ]);
        return result;
      } catch (err) {
        return {
          content: [{ type: "text", text: `Error: ${err.message}` }],
          isError: true,
        };
      }
    });
  }

  // Connect to cagent via stdio
  const stdioTransport = new StdioServerTransport();
  await server.connect(stdioTransport);

  process.stderr.write("[mcp-bridge] Bridge ready (stdio ↔ HTTP)\n");

  // Graceful shutdown
  const shutdown = async () => {
    process.stderr.write("[mcp-bridge] Shutting down...\n");
    try { await client.close(); } catch {}
    process.exit(0);
  };
  process.on("SIGTERM", shutdown);
  process.on("SIGINT", shutdown);
}

main().catch((err) => {
  process.stderr.write(`[mcp-bridge] Fatal: ${err.message}\n`);
  process.exit(1);
});
